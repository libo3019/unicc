


== Overview ==

libphorward serves as a parser generator and language processing toolchain. It provides a flexible, integrated and consequent solution for many parsing-related issues.


- **ppgram**, **ppsym** and **ppprod** objects provide a way to describe grammars, symbols and productions,
- **pppar** encapsulates a parser with a //plex//-based lexer,
- **ppast** is a linked data structure that represents parse trees generated by the parser, and allows for browsing it in any desired way.
-

We assume that the reader of this section is familiar with the terminology of parsing, grammars and algorithms.


== Grammars ==

Grammars are described using **ppgram** objects, which in turn are built from //terminal// and //nonterminal// symbols, described by **ppsym**, and productions, described by **ppprod**.

Whether a symbol is a terminal or a nonterminal is defined by its identifying name. Any symbol starting with a lower-case character in its name is identified as a //nonterminal// symbol. Symbols with an upper-case character or any other non-alphabetic character, as well as symbols entirely without an identifiying name, are treated as //terminal// symbols.

Here are some examples:

- ``expression`` is a nonterminal,
- ``Identifier`` is a terminal,
- ``_expression`` is a terminal,
- ``!`` is a terminal,
- ``xPRESSION`` is a nonterminal.
-

The distinction rules are defined within the macro @PPSYM_IS_TERMINAL(), and may be changed.

=== Hand-crafting a grammar ===

Grammars may be hand-crafted using the various construction functions for the
different objects.

Here is the little piece of code for little BNF-rule ``a: a A | b``:

```
ppgram* g;
ppsym*  a;
ppsym*  A;
ppsym*  b;

g = pp_gram_create();

a = pp_sym_create( g, "a", 0 );
A = pp_sym_create( g, "A", 0 );
b = pp_sym_create( g, "b", 0 );

pp_prod_create( g, a, a, A, NULL );         /* a: a A */
pp_prod_create( g, a, b, NULL );            /* a: b */

/* Alternatively: */
pprod*  p;

p = pp_prod_create( g, a, NULL );
pp_prod_append( p, a );
pp_prod_append( p, A );                     /* a: a A */

p = pp_prod_create( g, a, NULL );
pp_prod_append( p, b );                     /* a: b */
```

Indeed, this is nasty and error-prone.

=== Expressing grammars in Backus-Naur-Form ===

Grammars are usually expressed in Backus-Naur-Form (BNF).

For this case, the Phorward library provides parsers to compile BNF-like input into Phorward grammar objects.

- @pp_gram_from_bnf() - Simple parser to compile BNF without any extensions.
- @pp_gram_from_ebnf() - Extended parser to compile extended BNF definitions.
- @pp_gram_from_pbnf() - Full-fledged, Phorward-style BNF parser.
-

==== Simple BNF ====

Our above example grammar from the hand-crafting example can easily be constructed with the simple BNF parser, by using the function @pp_gram_from_bnf() on an previously created //ppgram//-object.

``` pp_gram_from_bnf( g, "a: a A | b;" );

The simple BNF parser allows for any symbol name which consists of any character except whitespace and the meta characters ``:``, ``|`` and ``;``. Generally, the rules for the naming of terminals and nonterminals, as described above, apply.

- ``:`` is the separator between left-hand side and productions,
- ``|`` is the separator between productions,
- ``;`` ends a definition block to start another one.
-

==== Extended BNF ====

The EBNF parser is the extended version of the simple BNF parser, and allows for further syntactical constructs.

These constructs are

- ``(`` and ``)`` construct inline-nonterminals with an automatically determined name, and allows for multiple productions,
- ``?`` behind a right-hand side symbol defines it as optional (optional closure),
- ``+`` behind a right-hand side symbol defines it as one-or-multiple (positive closure),
- ``*`` behind a right-hand side symbol defines it as none-or-multiple (kleene closure).
-

This example defines an (ambiguous) grammar for floating-point numbers:

```
pp_gram_from_ebnf( g, "dig : 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ;"
                      "float: dig+ . dig* | dig* . dig+ ;" );
```

==== Phorward BNF ====

The most powerful parser for grammars is the Phorward BNF parser (PBNF). This part of the Phorward library is still under construction and will be enhanced in the future to more features and elements.

In addition to the EBNF syntax, this dialect enables to define

- nodes in the resulting AST using the ``:=`` and ``=`` operators,
- lexical recognizers for terminal symbols, using ``"ast-node generating string"``, ``'string'`` and ``/regular expression/``,
- whitespace symbols via the ``%skip`` directive,
- a start symbol via ``$``.
-

The well known four-function calculator, expressed in pbnf:

```
%skip   /[\s]+/ ;
Int     : /[0-9]+/ = int;

factor  : Int
        | '(' expr ')'
        ;

term    : term '*' factor = mul
        | term '/' factor = div
        | factor
        ;

expr$   : expr '+' term = add
        | expr '-' term = sub
        | term
        ;
```

===== Associativity and precedence operators =====

With //pbnf//, in combination with the LALR parser, precedence and associativity can also be used to resolve conflicts and write shorter grammars. Thus, the following version of the four-function calculator yields the same parser.

```
%skip   /[\s]+/ ;
Int     : /[0-9]+/ = int;

<<      '+' '-';
<<      '*' '/';

expr$   : expr '*' expr = mul
        | expr '/' expr = div
        | expr '+' expr = add
        | expr '-' expr = sub
        | '(' expr ')'
        | Int
        ;
```

Here is a short table for reference.

|| Operator | Meaning |
| << | Left-associative configuration |
| >> | Right-associative configuration |
| ^^ | Non-associative configuration |


=== More grammar-related functions ===

There are some more functions on grammars that need to be mentioned.

- @pp_gram_prepare() prepares a grammar by generating additional compile-time-specific information that is required by subsequent tasks,
- @pp_gram_to_str() generates a BNF-like representation of the grammar,
- @PP_GRAM_DUMP() dumps a grammar's productions and symbols into trace,
- @pp_gram_free() frees a grammar object and all its values.
-


== Parsers ==

In definitions of the Phorward library, a parser is the union of a grammar, a lexical analyzer and a parsing algorithm.

- The grammar is the fundamental part of the parser, and is described via //ppgram//,
- as lexical analyzer, a //plex// object is used and managed, but this can also be changed to any other token emitting process,
- as parsing algorithm, so far only LALR(1) is supported, but more algorithms are planned in the future.
-

Parsers are described and implemented as a //pppar// object.

- @pp_par_create() creates an new parser object that is based on an existing grammar,
- @pp_par_lex() and @pp_par_autolex() allow to define tokens to be recognized by the //plex// object,
- @pp_par_parse() finally is the parser interpreter, that parses an input string and generates an AST from its structure,
- @pp_par_free() drops the parser object again.
-

The current state of Phorward's internal parsing tools run on strings (char*) only. Later extensions and enhancements may provide facilities to read from files or streams.

== Abstract Syntax Tree ==

The //ppast// object represents a node in the abstract syntax tree.

```
typedef struct _ppast       ppast;

/* AST */
struct _ppast
{
    char*                   emit;       /* AST node name */

    ppsym*                  sym;        /* Emitting symbol */
    ppprod*                 prod;       /* Emitting production */

    /* Match */
    char*                   start;      /* Begin of fragment */
    char*                   end;        /* End of fragment */
    size_t                  len;        /* Fragment length */

    /* Source */
    unsigned long           row;        /* Appearance in row */
    unsigned long           col;        /* Appearance in column */

    /* AST */
    ppast*                  child;      /* First child element */
    ppast*                  prev;       /* Previous element in current scope */
    ppast*                  next;       /* Next element in current scope */
};
```

It is usually not constructed by hand, but by parsing functions during parsing or when parsing has completed.

The following functions may be interesting:

- @pp_ast_dump() and @pp_ast_dump_short() dump a //ppast// as a textual tree into a stream, @PP_AST_DUMP() does so into the trace,
- @pp_ast_dump_json() dumps a //ppast// as JSON string into a stream,
- @pp_ast_dump_tree2svg() dumps a //ppast// as a string that can be fed to tree2svg, a free program to visually print trees,
- @pp_ast_eval() runs an evaluation on every node,
- @pp_ast_get() returns element from chain by index,
- @pp_ast_len() returns the length of a tree chain (by next pointer),
- @pp_ast_select() like @pp_ast_get(), but checking for same node names,
- @pp_ast_free() frees a //ppast// structure and all subsequent links.
-

