#
# Automake targets
#

bin_PROGRAMS = unicc$(EXEEXT)

if WITH_BOOTSTRAP
noinst_PROGRAMS = \
	boot_min_lalr1$(EXEEXT) \
	unicc_boot1$(EXEEXT) \
	unicc_boot2$(EXEEXT) \
	unicc_boot3$(EXEEXT)
endif

man1_MANS = unicc.man

uniccdir = $(datadir)/unicc
targetsdir = $(uniccdir)/targets
dist_targets_DATA = targets/c.tlt \
					targets/c++.tlt \
					targets/python.tlt \
					targets/javascript.tlt \
					targets/json.tlt

dist_unicc_DATA = unicc.dtd LICENSE README.md

AM_CPPFLAGS = -DTLTDIR=\"$(targetsdir)\"

#
# All sources except the grammar parser are equal in all bootstrappers.
#

SOURCES	= 	\
	lib/phorward.c \
	src/mem.c \
	src/error.c \
	src/first.c \
	src/lalr.c \
	src/utils.c \
	src/string.c \
	src/integrity.c \
	src/virtual.c \
	src/rewrite.c \
	src/debug.c \
	src/lex.c \
	src/list.c \
	src/build.c \
	src/buildxml.c \
	src/main.c \
	src/xml.c

if WITH_BOOTSTRAP

BUILT_SOURCES	=	\
	src/parse_boot1.c \
	src/parse_boot2.c \
	src/parse_boot2.h \
	src/parse_boot3.c \
	src/parse_boot3.h

# --- UniCC Bootstrap phase 0 --------------------------------------------------
#
# First we need to compile min_lalr1, which is a stand-alone parser generator
# that was written for experimental reasons before UniCC, but is needed by
# UniCC to bootstrap.
#

boot_min_lalr1_SOURCES = min_lalr1/min_lalr1.c

# --- UniCC Bootstrap phase 1 --------------------------------------------------
#
# This phase uses the experimental min_lalr1 Parser Generator to build a
# rudimentary parser for UniCC. min_lalr1 must be installed and in the PATH.
#

unicc_boot1_SOURCES = src/parse_boot1.c $(SOURCES)
unicc_boot1_CFLAGS = -DUNICC_BOOTSTRAP=1

src/parse_boot1.c: src/parse.min boot_min_lalr1$(EXEEXT)
	./boot_min_lalr1$(EXEEXT) src/parse.min >$@ 2>/dev/null

# --- UniCC Bootstrap phase 2 --------------------------------------------------
#
# In this phase, the parser generated by min_lalr1 is will be used to parse the
# grammar definition of the UniCC parser (parse.par)
#

unicc_boot2_SOURCES = src/parse_boot2.c $(SOURCES)
unicc_boot2_CFLAGS = -DUNICC_BOOTSTRAP=2
#unicc_boot2_DEPENDENCIES = unicc_boot1$(EXEEXT)

src/parse_boot2.c src/parse_boot2.h: src/parse.par unicc_boot1$(EXEEXT)
	./unicc_boot1$(EXEEXT) -svwb src/parse_boot2 src/parse.par

# --- UniCC Bootstrap phase 3 --------------------------------------------------
#
# In this phase, the UniCC parser compiled by UniCC will be used to build
# itself.
#

unicc_boot3_SOURCES = src/parse_boot3.c $(SOURCES)
unicc_boot3_CFLAGS = -DUNICC_BOOTSTRAP=3
#unicc_boot3_DEPENDENCIES = unicc_boot2$(EXEEXT)

src/parse_boot3.c src/parse_boot3.h: src/parse.par unicc_boot2$(EXEEXT)
	./unicc_boot2$(EXEEXT) -svwb src/parse_boot3 src/parse.par

endif

# --- UniCC Final Build --------------------------------------------------------
#
# Using the third bootstrap phase, the final UniCC executable is built.
#

unicc_SOURCES = src/parse.c $(SOURCES)
#unicc_DEPENDENCIES = unicc_boot3$(EXEEXT)

if WITH_BOOTSTRAP
src/parse.c src/parse.h: src/parse.par unicc_boot3$(EXEEXT)
	./unicc_boot3$(EXEEXT) -svwb src/parse src/parse.par
endif

